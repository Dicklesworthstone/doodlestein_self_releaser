#!/usr/bin/env bash
# dsr - Doodlestein Self-Releaser
#
# Fallback release infrastructure for when GitHub Actions is throttled.
#
# Usage:
#   dsr <command> [options]
#
# Commands:
#   check     Detect throttled GitHub Actions runs
#   watch     Continuous monitoring daemon
#   build     Build artifacts locally
#   release   Upload artifacts to GitHub
#   fallback  Full pipeline: check -> build -> release
#   repos     Manage repository registry
#   config    View/modify configuration
#   doctor    System diagnostics
#
# Global Options:
#   --json, -j          Machine-readable JSON output
#   --non-interactive   Disable prompts (CI mode)
#   --dry-run, -n       Show planned actions without executing
#   --verbose, -v       Enable verbose logging
#   --quiet, -q         Suppress non-error output
#   --help, -h          Show help
#   --version           Show version

set -uo pipefail

# Version
DSR_VERSION="0.1.0"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source modules (logging first, others may depend on it)
source "$SCRIPT_DIR/src/logging.sh"
source "$SCRIPT_DIR/src/config.sh"
source "$SCRIPT_DIR/src/signing.sh"
source "$SCRIPT_DIR/src/github.sh"

# Global flags
JSON_MODE=false
# shellcheck disable=SC2034  # Reserved for future use
DRY_RUN=false
VERBOSE=false
QUIET=false
# shellcheck disable=SC2034  # Reserved for future use
NON_INTERACTIVE=false

# Note: Colors and log functions are now provided by src/logging.sh
# The logging module provides: log_error, log_warn, log_info, log_debug, log_ok, log_timed

# Show help
show_help() {
    cat << 'EOF'
dsr - Doodlestein Self-Releaser

Fallback release infrastructure for when GitHub Actions is throttled.

USAGE:
    dsr <command> [options]

COMMANDS:
    check       Detect throttled GitHub Actions runs
    watch       Continuous monitoring daemon
    build       Build artifacts locally
    release     Upload artifacts to GitHub
    fallback    Full pipeline: check -> build -> release
    repos       Manage repository registry
    config      View/modify configuration
    doctor      System diagnostics
    signing     Manage minisign keys and signing

GLOBAL OPTIONS:
    -j, --json          Machine-readable JSON output
    -y, --non-interactive   Disable prompts (CI mode)
    -n, --dry-run       Show planned actions without executing
    -v, --verbose       Enable verbose logging
    -q, --quiet         Suppress non-error output
    -h, --help          Show this help
        --version       Show version

EXAMPLES:
    dsr config init              Initialize configuration
    dsr config show              Show current configuration
    dsr check --repos ntm,bv     Check if repos are throttled
    dsr build --repo ntm         Build ntm locally
    dsr doctor                   Check system dependencies

For more information, see docs/CLI_CONTRACT.md
EOF
}

# Show version
show_version() {
    if $JSON_MODE; then
        echo "{\"tool\": \"dsr\", \"version\": \"$DSR_VERSION\"}"
    else
        echo "dsr version $DSR_VERSION"
    fi
}

# JSON envelope helper
# Usage: json_envelope <command> <status> <exit_code> [details_json]
json_envelope() {
    local cmd="$1"
    local vstatus="$2"  # renamed to avoid potential conflict
    local exit_code="$3"
    local details="${4:-"{}"}"
    local run_id
    run_id=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "unknown")
    local started_at
    started_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat << EOF
{
  "command": "$cmd",
  "status": "$vstatus",
  "exit_code": $exit_code,
  "run_id": "$run_id",
  "started_at": "$started_at",
  "duration_ms": 0,
  "tool": "dsr",
  "version": "$DSR_VERSION",
  "details": $details
}
EOF
}

# ============================================================================
# CONFIG SUBCOMMAND
# ============================================================================

cmd_config() {
    local subcmd="${1:-show}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            cmd_config_init "$@"
            ;;
        show)
            cmd_config_show "$@"
            ;;
        get)
            cmd_config_get "$@"
            ;;
        set)
            cmd_config_set "$@"
            ;;
        validate)
            cmd_config_validate "$@"
            ;;
        edit)
            cmd_config_edit "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr config - View and modify configuration

USAGE:
    dsr config <subcommand> [options]

SUBCOMMANDS:
    init        Initialize configuration directories and files
    show        Show current configuration
    get <key>   Get a specific config value
    set <k>=<v> Set a config value
    validate    Validate configuration files
    edit        Open config in $EDITOR

OPTIONS:
    --json      Output in JSON format
    --force     Overwrite existing files (init only)

EXAMPLES:
    dsr config init              Create default config files
    dsr config show              Show all configuration
    dsr config get threshold_seconds
    dsr config set log_level=debug
    dsr config validate
EOF
            ;;
        *)
            log_error "Unknown config subcommand: $subcmd"
            log_info "Run 'dsr config --help' for usage"
            return 4
            ;;
    esac
}

cmd_config_init() {
    local force=false
    [[ "${1:-}" == "--force" ]] && force=true

    if $JSON_MODE; then
        local status
        if $force; then
            config_init --force >/dev/null 2>&1
            status=$?
        else
            config_init >/dev/null 2>&1
            status=$?
        fi
        if [[ $status -eq 0 ]]; then
            json_envelope "config init" "success" 0 "{\"config_dir\": \"$DSR_CONFIG_DIR\", \"initialized\": true}"
        else
            json_envelope "config init" "error" $status "{\"error\": \"initialization failed\"}"
        fi
        return $status
    else
        if $force; then
            config_init --force
        else
            config_init
        fi
    fi
}

cmd_config_show() {
    if $JSON_MODE; then
        config_show --json
    else
        config_show "$@"
    fi
}

cmd_config_get() {
    local key="${1:-}"
    if [[ -z "$key" ]]; then
        log_error "Usage: dsr config get <key>"
        return 4
    fi

    config_load
    local value
    value=$(config_get "$key" "")

    if [[ -z "$value" ]]; then
        log_error "Key not found: $key"
        return 4
    fi

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\"}"
    else
        echo "$value"
    fi
}

cmd_config_set() {
    local input="${1:-}"
    if [[ -z "$input" || ! "$input" =~ = ]]; then
        log_error "Usage: dsr config set KEY=VALUE"
        return 4
    fi

    local key="${input%%=*}"
    local value="${input#*=}"

    config_load
    config_set "$key" "$value" --persist

    if $JSON_MODE; then
        echo "{\"key\": \"$key\", \"value\": \"$value\", \"persisted\": true}"
    fi
}

cmd_config_validate() {
    if $JSON_MODE; then
        config_load
        if config_validate 2>/dev/null; then
            json_envelope "config validate" "success" 0 "{\"valid\": true}"
        else
            json_envelope "config validate" "error" 4 "{\"valid\": false}"
            return 4
        fi
    else
        config_load
        config_validate
    fi
}

cmd_config_edit() {
    local editor="${EDITOR:-vi}"
    if [[ ! -f "$DSR_CONFIG_FILE" ]]; then
        log_error "Config file not found. Run: dsr config init"
        return 4
    fi
    exec "$editor" "$DSR_CONFIG_FILE"
}

# ============================================================================
# DOCTOR SUBCOMMAND (stub)
# ============================================================================

cmd_doctor() {
    log_info "Running system diagnostics..."

    local errors=0
    local warnings=0
    local checks=()

    # Helper to escape JSON strings
    _json_escape() {
        printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\n/\\n/g'
    }

    # Check git
    if command -v git &>/dev/null; then
        local git_ver
        git_ver=$(git --version | cut -d' ' -f3)
        checks+=("{\"name\": \"git\", \"status\": \"ok\", \"version\": \"$(_json_escape "$git_ver")\"}")
        log_ok "git: $git_ver"
    else
        checks+=("{\"name\": \"git\", \"status\": \"error\", \"message\": \"not found\"}")
        log_error "git: not found"
        ((errors++))
    fi

    # Check gh
    if command -v gh &>/dev/null; then
        if gh auth status &>/dev/null 2>&1; then
            checks+=("{\"name\": \"gh\", \"status\": \"ok\", \"authenticated\": true}")
            log_ok "gh: authenticated"
        else
            checks+=("{\"name\": \"gh\", \"status\": \"warning\", \"authenticated\": false}")
            log_warn "gh: not authenticated (run: gh auth login)"
            ((warnings++))
        fi
    else
        checks+=("{\"name\": \"gh\", \"status\": \"error\", \"message\": \"not found\"}")
        log_error "gh: not found"
        ((errors++))
    fi

    # Check docker
    if command -v docker &>/dev/null; then
        if docker info &>/dev/null 2>&1; then
            checks+=("{\"name\": \"docker\", \"status\": \"ok\", \"running\": true}")
            log_ok "docker: running"
        else
            checks+=("{\"name\": \"docker\", \"status\": \"warning\", \"running\": false}")
            log_warn "docker: not running"
            ((warnings++))
        fi
    else
        checks+=("{\"name\": \"docker\", \"status\": \"warning\", \"message\": \"not found\"}")
        log_warn "docker: not found (needed for act)"
        ((warnings++))
    fi

    # Check act
    if command -v act &>/dev/null; then
        local act_ver
        act_ver=$(act --version 2>/dev/null | head -1)
        checks+=("{\"name\": \"act\", \"status\": \"ok\", \"version\": \"$(_json_escape "$act_ver")\"}")
        log_ok "act: $act_ver"
    else
        checks+=("{\"name\": \"act\", \"status\": \"warning\", \"message\": \"not found\"}")
        log_warn "act: not found (needed for local builds)"
        ((warnings++))
    fi

    # Check SSH to build hosts
    for host in mmini wlap; do
        if timeout 5 ssh -o ConnectTimeout=3 "$host" "echo ok" &>/dev/null 2>&1; then
            checks+=("{\"name\": \"ssh-$host\", \"status\": \"ok\"}")
            log_ok "ssh $host: reachable"
        else
            checks+=("{\"name\": \"ssh-$host\", \"status\": \"warning\", \"message\": \"unreachable\"}")
            log_warn "ssh $host: unreachable"
            ((warnings++))
        fi
    done

    # Check config
    config_load 2>/dev/null || true
    if config_validate &>/dev/null 2>&1; then
        checks+=("{\"name\": \"config\", \"status\": \"ok\"}")
        log_ok "config: valid"
    else
        checks+=("{\"name\": \"config\", \"status\": \"warning\", \"message\": \"invalid or missing\"}")
        log_warn "config: invalid or missing (run: dsr config init)"
        ((warnings++))
    fi

    # Summary
    echo ""
    if [[ $errors -gt 0 ]]; then
        log_error "Found $errors error(s), $warnings warning(s)"
        local exit_code=3
    elif [[ $warnings -gt 0 ]]; then
        log_warn "Found $warnings warning(s)"
        local exit_code=0
    else
        log_ok "All checks passed"
        local exit_code=0
    fi

    if $JSON_MODE; then
        local checks_json details_json
        # Use compact output (-c) to avoid multiline issues in string interpolation
        checks_json=$(printf '%s\n' "${checks[@]}" | jq -sc '.')
        # Build details as proper JSON object using jq for correctness
        details_json=$(jq -nc --argjson errors "$errors" --argjson warnings "$warnings" --argjson checks "$checks_json" \
            '{errors: $errors, warnings: $warnings, checks: $checks}')
        json_envelope "doctor" "$([ $errors -eq 0 ] && echo success || echo error)" "$exit_code" "$details_json"
    fi

    return $exit_code
}

# ============================================================================
# STUB COMMANDS (to be implemented)
# ============================================================================

# ============================================================================
# CHECK SUBCOMMAND
# ============================================================================

cmd_check() {
    local repos=()
    local threshold=600  # 10 minutes in seconds
    local check_all=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --repos|-r)
                IFS=',' read -ra repos <<< "$2"
                shift 2
                ;;
            --threshold|-t)
                threshold="$2"
                shift 2
                ;;
            --all|-a)
                check_all=true
                shift
                ;;
            --help|-h)
                cat << 'EOF'
dsr check - Detect throttled GitHub Actions runs

USAGE:
    dsr check <repo>
    dsr check --repos repo1,repo2
    dsr check --all

OPTIONS:
    -r, --repos <list>      Comma-separated repos (e.g., ntm,bv)
    -t, --threshold <sec>   Queue time threshold in seconds (default: 600)
    -a, --all               Check all configured repos
    --json                  JSON output (global flag)

EXAMPLES:
    dsr check Dicklesworthstone/ntm
    dsr check --repos ntm,bv --threshold 300
    dsr check --all --json

EXIT CODES:
    0  - No throttling detected
    1  - Throttling detected
    3  - Dependency error (gh not authenticated)
    4  - Invalid arguments
    8  - Network/API error
EOF
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Run 'dsr check --help' for usage"
                return 4
                ;;
            *)
                # Positional argument - repo
                repos+=("$1")
                shift
                ;;
        esac
    done

    # Load config for --all option
    if $check_all; then
        config_load 2>/dev/null || true
        # Get repos from config (parse repos.yaml)
        local repos_file="$DSR_CONFIG_DIR/repos.yaml"
        if [[ -f "$repos_file" ]]; then
            while IFS= read -r repo; do
                [[ -n "$repo" ]] && repos+=("$repo")
            done < <(grep -E '^\s+repo:' "$repos_file" 2>/dev/null | sed 's/.*repo:\s*//' | tr -d '"' || true)
        fi
    fi

    # Validate we have repos to check
    if [[ ${#repos[@]} -eq 0 ]]; then
        log_error "No repos specified. Use: dsr check <repo> or --all"
        return 4
    fi

    # Check dependencies
    if ! gh_check 2>/dev/null; then
        if ! gh_check_token 2>/dev/null; then
            if $JSON_MODE; then
                json_envelope "check" "error" 3 '{"error": "GitHub authentication required"}'
            fi
            return 3
        fi
    fi

    # Process each repo
    local any_throttled=false
    local results=()
    local now
    now=$(date +%s)

    for repo in "${repos[@]}"; do
        local result
        result=$(_check_repo "$repo" "$threshold" "$now")
        local status=$?

        if [[ $status -eq 1 ]]; then
            any_throttled=true
        fi

        results+=("$result")

        if ! $JSON_MODE; then
            _check_print_result "$result"
        fi
    done

    # JSON output
    if $JSON_MODE; then
        local results_json
        results_json=$(printf '%s\n' "${results[@]}" | jq -sc '.')
        local summary_status="ok"
        $any_throttled && summary_status="throttled"
        json_envelope "check" "$summary_status" "$($any_throttled && echo 1 || echo 0)" \
            "$(jq -nc --argjson repos "$results_json" --argjson threshold "$threshold" \
                '{threshold_seconds: $threshold, repos: $repos}')"
    fi

    $any_throttled && return 1 || return 0
}

# Check a single repo for throttling
# Returns JSON result, exit code 1 if throttled
_check_repo() {
    local repo="$1"
    local threshold="$2"
    local now="$3"

    # Resolve short repo name to owner/repo
    if [[ ! "$repo" =~ / ]]; then
        # Assume Dicklesworthstone if no owner specified
        repo="Dicklesworthstone/$repo"
    fi

    # Fetch workflow runs
    local runs_json
    runs_json=$(gh_workflow_runs "$repo" --limit 20 2>/dev/null)
    local fetch_status=$?

    if [[ $fetch_status -ne 0 ]] || [[ -z "$runs_json" ]]; then
        echo '{"repo": "'"$repo"'", "status": "error", "error": "failed to fetch runs"}'
        return 8
    fi

    # Extract and analyze runs
    local queued_runs stuck_runs
    queued_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "queued")) |
        map(. as $run |
            ($now - ($run.created_at | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    stuck_runs=$(echo "$runs_json" | jq -c --argjson now "$now" --argjson threshold "$threshold" '
        .workflow_runs // [] |
        map(select(.status == "in_progress")) |
        map(. as $run |
            ($run.run_started_at // $run.created_at) as $start_time |
            ($now - ($start_time | fromdateiso8601 // $now)) as $age |
            select($age > $threshold) |
            {
                id: .id,
                status: .status,
                created_at: .created_at,
                run_started_at: .run_started_at,
                workflow_id: .workflow_id,
                workflow_name: .name,
                event: .event,
                html_url: .html_url,
                age_seconds: $age
            }
        )' 2>/dev/null || echo '[]')

    # Count issues
    local queued_count stuck_count
    queued_count=$(echo "$queued_runs" | jq 'length')
    stuck_count=$(echo "$stuck_runs" | jq 'length')

    # Determine oldest queued time
    local oldest_queued_sec=0
    if [[ "$queued_count" -gt 0 ]]; then
        oldest_queued_sec=$(echo "$queued_runs" | jq '[.[].age_seconds] | max // 0')
    fi

    # Build result
    local status="ok"
    if [[ "$queued_count" -gt 0 ]] || [[ "$stuck_count" -gt 0 ]]; then
        status="throttled"
    fi

    jq -nc \
        --arg repo "$repo" \
        --arg status "$status" \
        --argjson threshold "$threshold" \
        --argjson queued_count "$queued_count" \
        --argjson stuck_count "$stuck_count" \
        --argjson oldest_queued_sec "$oldest_queued_sec" \
        --argjson queued_runs "$queued_runs" \
        --argjson stuck_runs "$stuck_runs" \
        '{
            repo: $repo,
            status: $status,
            threshold_seconds: $threshold,
            queued_count: $queued_count,
            stuck_in_progress_count: $stuck_count,
            oldest_queued_seconds: $oldest_queued_sec,
            oldest_queued_minutes: (($oldest_queued_sec / 60) | floor),
            queued_runs: $queued_runs,
            stuck_runs: $stuck_runs
        }'

    [[ "$status" == "throttled" ]] && return 1 || return 0
}

# Print human-readable check result
_check_print_result() {
    local result="$1"

    local repo status queued stuck oldest_min
    repo=$(echo "$result" | jq -r '.repo')
    status=$(echo "$result" | jq -r '.status')
    queued=$(echo "$result" | jq -r '.queued_count')
    stuck=$(echo "$result" | jq -r '.stuck_in_progress_count')
    oldest_min=$(echo "$result" | jq -r '.oldest_queued_minutes')

    if [[ "$status" == "error" ]]; then
        log_error "$repo: $(echo "$result" | jq -r '.error // "unknown error"')"
    elif [[ "$status" == "throttled" ]]; then
        log_warn "$repo: THROTTLED"
        [[ "$queued" -gt 0 ]] && log_warn "  - $queued runs queued (oldest: ${oldest_min}m)"
        [[ "$stuck" -gt 0 ]] && log_warn "  - $stuck runs stuck in_progress"

        # Show URLs for queued runs
        echo "$result" | jq -r '.queued_runs[:3][] | "    â†’ \(.html_url)"' 2>/dev/null | while read -r url; do
            log_info "$url"
        done
    else
        log_ok "$repo: OK (no throttling detected)"
    fi
}

cmd_watch() {
    log_warn "watch command not yet implemented"
    log_info "See bead bd-1jt.1.2 for implementation plan"
    return 4
}

cmd_build() {
    log_warn "build command not yet implemented"
    log_info "See bead bd-1jt.2.1 for implementation plan"
    return 4
}

cmd_release() {
    log_warn "release command not yet implemented"
    log_info "See bead bd-1jt.3.1 for implementation plan"
    return 4
}

cmd_fallback() {
    log_warn "fallback command not yet implemented"
    log_info "See bead bd-1jt.1.4 for implementation plan"
    return 4
}

cmd_repos() {
    log_warn "repos command not yet implemented"
    log_info "See bead bd-1jt.1.3 for implementation plan"
    return 4
}

# ============================================================================
# SIGNING SUBCOMMAND
# ============================================================================

cmd_signing() {
    local subcmd="${1:-check}"
    shift 2>/dev/null || true

    case "$subcmd" in
        init)
            signing_init "$@"
            ;;
        check)
            if $JSON_MODE; then
                signing_check --json
            else
                signing_check
            fi
            ;;
        sign)
            signing_sign "$@"
            ;;
        verify)
            signing_verify "$@"
            ;;
        fix)
            signing_fix_permissions
            ;;
        pubkey|public-key)
            signing_get_public_key "$@"
            ;;
        --help|-h|help)
            cat << 'EOF'
dsr signing - Manage minisign keys and artifact signing

USAGE:
    dsr signing <subcommand> [options]

SUBCOMMANDS:
    init        Generate new keypair (interactive)
    check       Verify keypair is configured
    sign        Sign a file
    verify      Verify a file signature
    fix         Fix private key permissions
    pubkey      Display public key

EXAMPLES:
    dsr signing init              Generate new keypair
    dsr signing check             Check if keys are configured
    dsr signing sign artifact.tar.gz
    dsr signing verify artifact.tar.gz
    dsr signing pubkey --oneline  Get public key for embedding

For more information, see docs/CLI_CONTRACT.md
EOF
            ;;
        *)
            log_error "Unknown signing subcommand: $subcmd"
            log_info "Run 'dsr signing --help' for usage"
            return 4
            ;;
    esac
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    # shellcheck disable=SC2034  # DRY_RUN/NON_INTERACTIVE reserved for future use
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json|-j)
                JSON_MODE=true
                shift
                ;;
            --dry-run|-n)
                DRY_RUN=true
                shift
                ;;
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --quiet|-q)
                QUIET=true
                shift
                ;;
            --non-interactive|-y)
                NON_INTERACTIVE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -*)
                # Unknown option - might be command-specific
                break
                ;;
            *)
                # Not an option - must be command
                break
                ;;
        esac
    done

    # Initialize logging with appropriate level
    log_set_level_from_flags "$VERBOSE" "$QUIET"
    log_init

    # Get command
    local command="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi

    # Set command context for logging
    log_set_command "$command"

    # Dispatch to command handler
    case "$command" in
        config)
            cmd_config "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        check)
            cmd_check "$@"
            ;;
        watch)
            cmd_watch "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        release)
            cmd_release "$@"
            ;;
        fallback)
            cmd_fallback "$@"
            ;;
        repos)
            cmd_repos "$@"
            ;;
        signing)
            cmd_signing "$@"
            ;;
        help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown command: $command"
            log_info "Run 'dsr --help' for usage"
            exit 4
            ;;
    esac
}

main "$@"
